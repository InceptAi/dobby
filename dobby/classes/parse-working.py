"""Base class for parsing summaries generated by click.
"""
from __future__ import division
from copy import deepcopy
from collections import Counter, defaultdict
from enum import Enum, unique
from classes.endpoint import EndPoint
from classes.edge import EdgeType, Edge
from classes.node import NodeType, Node
from classes.flow import Flow, TCPFlow
from classes.app import NetworkApp
from classes.phymodel import PhysicalAddress, PhysicalModel, WifiPhysicalModel
from classes.metrics import Stats, Metrics, WirelessMetrics, TCPMetrics
from classes.ipinfo import IPInfo
import json

__author__ = """\n""".join(['Vivek Shrivastava (vivek@obiai.tech)'])

# Keyed by MAC
MAC_TO_ENDPOINTS = {}
# Keyed by IP
IP_TO_ENDPOINTS = {}
# Keyed by node uuid
NODES = {}
# Keyed by endpoint macs
EDGES = {}
# Keyed by flow ip:port->ip:port
IP_FLOWS = {}
# Keyed by the BSSID + Channel --> a given AP on a given channel
PHYMODELS = {}
# Keyed by app uuid
APPS = {}

# Assuming we represent values as 10/50/90 percentile
def convert_to_stats(value_string, num_samples):
    if not value_string:
        return None
    try:
        vals = value_string.split('/')
        stats = Stats(percentile_10=float(vals[0]),
                      percentile_50=float(vals[1]),
                      percentile_90=float(vals[2]),
                      num_samples=float(num_samples))
    except:
        print ("Incorrect string format: (per_10/per_50/per_90)")
        return None
    else:
        return stats

def get_float_value(json_dict, key):
    try:
        value = float(json_dict[key]) if json_dict.get(key, None) else None
    except ValueError:
        print ("Cannot convert to float", json_dict.get(key, None))
        return None
    else:
        return value

class IllegalArgumentError(ValueError):
    pass


class ParseWirelessSummary(object):
    """Parses wireless summary generated by click
    """
    def __init__(self, fname=None, wireless_json=None):
        if not fname and not wireless_json:
            raise IllegalArgumentError("Either json file or string must be input")
        if wireless_json:
            self.wireless_json = wireless_json
        else:
            # Read in the summary
            try:
                with open(fname) as f:
                    self.wireless_json = json.load(f)
            except (OSError, IOError) as e:
                raise IllegalArgumentError("Cannot read file", fname)

    def parse_summary(self):
        #Iterate and update the endpoint stats
        for link in self.wireless_json['links']['link']:
            ap = link['@ap']
            client = link['@client']
            bssid = link['@bssid']
            #TODO -- flow the channel information click
            channel = link.get('@channel', 0)
            #TODO -- flow the SSID information from click

            #Create physical addresses
            ap_addr = PhysicalAddress(ap)
            client_addr = PhysicalAddress(client)
            bssid_addr = PhysicalAddress(bssid)

            # Create a phyModel for bssid
            wifi_model = PHYMODELS.get((str(bssid_addr), channel) , None)
            if wifi_model is None:
                # Create wifi model
                wifi_model = WifiPhysicalModel(mac=bssid_addr, channel=channel)
            else:
                wifi_model.add_clients(clients=[client_addr])

            # Create an endpoint entry for ap/client
            ap_endpoint = MAC_TO_ENDPOINTS.get(str(ap_addr), None)
            if not ap_endpoint:
                ap_endpoint = EndPoint(phy_address=ap_addr,
                                       phy_model=wifi_model)
                #TODO: It should be one AP node per ssid -- right now it is one AP node per mac
                #Create a new node for the AP
                ap_node = Node(endpoints=[ap_endpoint], node_type=NodeType.WIRELESS_ROUTER)
                ap_endpoint.node_id = ap_node.node_id
                MAC_TO_ENDPOINTS[str(ap_addr)] = ap_endpoint
                NODES[ap_node.node_id] = ap_node

            client_endpoint = MAC_TO_ENDPOINTS.get(str(client_addr), None)
            if not client_endpoint:
                client_endpoint = EndPoint(phy_address=client_addr,
                                           phy_model=wifi_model)
                client_node = Node(endpoints=[client_endpoint], node_type=NodeType.WIRELESS_CLIENT)
                client_endpoint.node_id = client_node.node_id
                MAC_TO_ENDPOINTS[str(client_addr)] = client_endpoint
                NODES[client_node.node_id] = client_node

            # Create an edge for this
            edge = EDGES.get((str(ap_addr), str(client_addr)), None)
            if not edge:
                edge = Edge(endpoint_a=ap_addr, endpoint_b=client_addr, edge_type=EdgeType.PHYSICAL)

            if type(link['stream']) != list:
                stream_list = [link['stream']]
            else:
                stream_list = link['stream']
            for stream in stream_list:
                assert(type(stream) == dict)
                start_ts = stream.get('@start_ts', None)
                if start_ts:
                    start_ts = int(start_ts)
                end_ts = stream.get('@end_ts', None)
                if end_ts:
                    end_ts = int(end_ts)
                total_data_bytes = get_float_value(stream, '@total_data_bytes')
                total_data_pkts = get_float_value(stream, '@total_data_pkts')
                total_pkts = get_float_value(stream, '@total_pkts')
                total_retx = get_float_value(stream, '@total_retx')
                total_trans_time_usec = get_float_value(stream, '@total_trans_time_usec')
                avg_data_pkt_duration_usec = get_float_value(stream, '@avg_data_pkt_duration_usec')
                rate_stats = convert_to_stats(stream.get('@rate', None), total_pkts)
                size_stats = convert_to_stats(stream.get('@size', None), total_pkts)
                snr_stats = convert_to_stats(stream.get('@snr', None), total_pkts)
                metrics_to_add = WirelessMetrics(start_ts=start_ts, end_ts=end_ts,
                                                 total_pkts=total_pkts,
                                                 total_data_pkts=total_data_pkts,
                                                 total_data_bytes=total_data_bytes,
                                                 total_retx=total_retx, snr_stats=snr_stats,
                                                 rate_stats=rate_stats, size_stats=size_stats,
                                                 total_trans_time_usec=total_trans_time_usec,
                                                 avg_data_pkt_duration_usec=avg_data_pkt_duration_usec)
                #if stream['@dir'] == "TODS":
                #TODO--switch this back to TODS in click
                if stream['@dir'] == "CLIENT-AP":
                    #AP - a, client - b, this metric is for b->a
                    print ("TODS: Adding edge metrics for:", str(ap_addr), str(client_addr))
                    edge.update_metrics_ba(metrics_to_add)
                #if stream['@dir'] == "FROMDS":
                #TODO--switch this back to FROMDS in click
                if stream['@dir'] == "AP-CLIENT":
                    #AP - a, client - b, this metric is for a->b
                    print ("FROMDS: Adding edge metrics for:", str(ap_addr), str(client_addr))
                    edge.update_metrics_ab(metrics_to_add)
                if stream['@dir'] == "NODS":
                    #TODO -- fix this
                    #Not clear which is a and b here
                    edge.update_undirected_metrics(metrics_to_add)
                #if stream['@dir'] == "DSTODS":
                #TODO--switch this back to DSTODS in click
                if stream['@dir'] == "AP-AP":
                    #TODO -- fix this
                    #Not clear which is a and b here
                    edge.update_undirected_metrics(metrics_to_add)

            #Inserting the physical model into the global dict
            PHYMODELS[(str(bssid_addr), channel)] = wifi_model
            #Inserting the edge into the global edges table
            EDGES[(str(ap_addr), str(client_addr))] = edge
            #TODO -- update the interferers by checking for other bssids on the same channel
            #TODO -- Add nodes for physical endpoints and ips
        #print ("PHYMODELS", PHYMODELS)
        #print ("MAC_TO_ENDPOINTS", MAC_TO_ENDPOINTS)
        #print ("EDGES", EDGES)
        #print ("NODES", NODES)


class ParseNodeSummary(object):
    """Parses wireless summary generated by click
    """
    def __init__(self, json_file=None):
        # Read in the summary
        with open(opts.json_file) as f:
            self.node_json = json.load(f)

    def parse_summary(self):
        #Iterate and update the endpoint stats
        for node in self.node_json['nodes']['node']:
            mac = node['@ether']
            vendor = node['@vendor']
            phy_addr = PhysicalAddress(phy_address=mac, vendor=vendor)
            # See if this endpoint exists
            endpoint = MAC_TO_ENDPOINTS.get(str(phy_addr), None)
            if endpoint:
                #Endpoint exists. Just update the vendor
                endpoint.phy_address.update_vendor(vendor)
            else:
                endpoint = EndPoint(phy_addr)
                MAC_TO_ENDPOINTS[str(phy_addr)] = endpoint
            # Check if a corresponding node exists
            if endpoint.node_id:
                node = NODES.get(endpoint.node_id, None)
                assert(node)
            else:
                # Create a node
                node = Node(endpoints=[endpoint], node_type=NodeType.UNKNOWN)
                endpoint.node_id = node.node_id
                NODES[node.node_id] = node

            for ip in node['ip']:
                # For each IP address, create an IPInfo element and create a node.
                ip_info = IPInfo(ipv4address=ip['addr'], hostname=ip.get('hostname', None))
                if node.node_type == NodeType.WIRELESS_ROUTER:
                    # Create an endpoint with ip_info -- assign it to the endpoint above if not AP
                    # TODO remove this hack -- IP-->MAC should be derived from ARP requests
                    ip_endpoint = EndPoint(ip_info = ip_info)
                    ip_node = Node(endpoints=[ip_endpoint], node_type=NodeType.CLOUD_IP)
                    ip_endpoint.node_id = ip_node.node_id
                    IP_TO_ENDPOINTS[str(ip_info.ipv4address)] = ip_endpoint
                    NODES[ip_node.node_id] = ip_node
                else:
                    # Add to the MAC endpoint above
                    endpoint.update_ip(ip_info=ip_info)
                    IP_TO_ENDPOINTS[str(ip_info.ipv4address)] = endpoint


def convert_rtt_json_to_stats(rtt_json):
    if not rtt_json:
        return None
    rtt_dict = {}
    # Generate the metrics for RTT/Semirtt/Loss
    for rtt in rtt_json:
        rtt_dict[rtt['@source']] = get_float_value(rtt, '@value')
    return Stats(min_val=rtt_dict.get('min', None),
                 avg_val=rtt_dict.get('avg', None),
                 max_val=rtt_dict.get('max', None),
                 var_val=rtt_dict.get('var', None))

class ParseTCPMysterySummary(object):
    """Parses wireless summary generated by click
    """
    def __init__(self, fname=None, tcpmystery_json=None):
        if not fname and not tcpmystery_json:
            raise IllegalArgumentError("Either json file or string must be input")
        if tcpmystery_json:
            self.tcpmystery_json = tcpmystery_json
        else:
            # Read in the summary
            try:
                with open(fname) as f:
                    self.tcpmystery_json = json.load(f)
            except (OSError, IOError) as e:
                raise IllegalArgumentError("Cannot read file", fname)

    def parse_summary(self):
        # First parse tcpmystery
        for flow in self.tcpmystery_json['trace']['flow']:
            tcp_flow_info = {}
            tcp_metrics_parameters = {}
            tcp_metrics_directional_parameters_0 = {}
            tcp_metrics_directional_parameters_1 = {}

            src_ip = IPInfo(ipv4address=flow['@src'])
            src_ip_endpoint = IP_TO_ENDPOINTS.get(str(src_ip.ipv4address), None)
            if not src_ip_endpoint:
                src_ip_endpoint = EndPoint(ip_info=src_ip)
            if not src_ip_endpoint.node_id:
                src_ip_node = Node(endpoints=[src_ip_endpoint], node_type=NodeType.UNKNOWN)
                src_ip_endpoint.node_id = src_ip_node.node_id
                NODES[src_ip_node.node_id] = src_ip_node
            else:
                src_ip_node = NODES[src_ip_endpoint.node_id]
            IP_TO_ENDPOINTS[str(src_ip.ipv4address)] = src_ip_endpoint

            dst_ip = IPInfo(ipv4address=flow['@dst'])
            dst_ip_endpoint = IP_TO_ENDPOINTS.get(str(dst_ip.ipv4address), None)
            if not dst_ip_endpoint:
                dst_ip_endpoint = EndPoint(ip_info=dst_ip)
            if not dst_ip_endpoint.node_id:
                dst_ip_node = Node(endpoints=[dst_ip_endpoint], node_type=NodeType.UNKNOWN)
                dst_ip_endpoint.node_id = dst_ip_node.node_id
                NODES[dst_ip_node.node_id] = dst_ip_node
            else:
                dst_ip_node = NODES[dst_ip_endpoint.node_id]
            IP_TO_ENDPOINTS[str(dst_ip.ipv4address)] = dst_ip_endpoint

            sport = get_float_value(flow, '@sport')
            dport = get_float_value(flow, '@dport')
            begin = get_float_value(flow, '@begin')
            duration = get_float_value(flow, '@duration')
            flow_key = str(src_ip.ipv4address) + "-" + str(int(sport)) + "-" +\
                       str(dst_ip.ipv4address) + "-" + str(int(dport))
            # Generate the metrics for RTT/Semirtt/Loss
            rtt_stats = convert_rtt_json_to_stats(flow.get('rtt', None))
            tcp_metrics = TCPMetrics(start_ts=begin, end_ts=(begin + duration),
                                     rtt_stats=rtt_stats, duration=duration)
            tcp_metrics_parameters = dict(start_ts=begin, end_ts=(begin + duration), rtt_stats=rtt_stats, duration=duration)
            tcp_flow_info.update(src_endpoint=src_ip_endpoint,
                                 dst_endpoint=dst_ip_endpoint,
                                 sport=sport,
                                 dport=dport,
                                 flow_metrics=tcp_metrics)

            # Generate the metrics for each direction
            for stream in flow['stream']:
                mtu = get_float_value(stream, '@mtu')
                nack = get_float_value(stream,'@nack')
                ndata = get_float_value(stream, '@ndata')
                nbytes = get_float_value(stream, '@seqlen')
                rtt_stats = convert_rtt_json_to_stats(stream.get('semirtt', None))
                tcp_metrics_directional = TCPMetrics(start_ts=begin, end_ts=(begin + duration),
                                                     rtt_stats=rtt_stats, mtu=mtu,
                                                     total_pkts=ndata, total_acks=nack,
                                                     total_bytes=nbytes)
                tcp_metrics_directional_parameters = dict(start_ts=begin, end_ts=(begin + duration),
                                                     rtt_stats=rtt_stats, mtu=mtu,
                                                     total_acks=nack,
                                                     total_pkts=ndata,
                                                     total_bytes=nbytes)
                if int(stream['@dir']) == 0:
                    tcp_flow_info.update(flow_metrics_src_to_dst=tcp_metrics_directional)
                    tcp_metrics_directional_parameters_0 = tcp_metrics_directional_parameters
                else:
                    tcp_flow_info.update(flow_metrics_dst_to_src=tcp_metrics_directional)
                    tcp_metrics_directional_parameters_1 = tcp_metrics_directional_parameters

            #Get the tcp flow and insert it into the IP_FLOWS dict
            tcp_flow = IP_FLOWS.get(flow_key, None)
            if not tcp_flow:
                tcp_flow = TCPFlow(**tcp_flow_info)
                IP_FLOWS[flow_key] = tcp_flow
            else:
                tcp_flow.update_flow_metrics(**tcp_metrics_parameters)
                tcp_flow.update_flow_metrics_src_to_dst(**tcp_metrics_directional_parameters_0)
                tcp_flow.update_flow_metrics_dst_to_src(**tcp_metrics_directional_parameters_1)

class ParseTCPLossSummary(object):
    """Parses wireless summary generated by click
    """
    def __init__(self, fname=None, tcploss_json=None):
        if not fname and not tcploss_json:
            raise IllegalArgumentError("Either json file or string must be input")
        if tcploss_json:
            self.tcploss_json = tcploss_json
        else:
            # Read in the summary
            try:
                with open(fname) as f:
                    self.tcploss_json = json.load(f)
            except (OSError, IOError) as e:
                raise IllegalArgumentError("Cannot read file", fname)


    def parse_tcploss_json(self):
        # Parse tcploss.json
        for flow in self.tcploss_json['@trace']['flow']:
            tcp_flow_info = {}
            src_ip = IPInfo(ipv4address=flow['@src'])
            src_ip_endpoint = IP_TO_ENDPOINTS.get(str(src_ip.ipv4address), None)
            if not src_ip_endpoint:
                src_ip_endpoint = EndPoint(ip_info=src_ip)
            if not src_ip_endpoint.node_id:
                src_ip_node = Node(endpoints=[src_ip_endpoint], node_type=NodeType.UNKNOWN)
                src_ip_endpoint.node_id = src_ip_node.node_id
                NODES[src_ip_node.node_id] = src_ip_node
            else:
                src_ip_node = NODES[src_ip_endpoint.node_id]
            IP_TO_ENDPOINTS[str(src_ip.ipv4address)] = src_ip_endpoint
            tcp_flow_info['src_endpoint'] = src_ip_endpoint

            dst_ip = IPInfo(ipv4address=flow['@dst'])
            dst_ip_endpoint = IP_TO_ENDPOINTS.get(str(dst_ip.ipv4address), None)
            if not dst_ip_endpoint:
                dst_ip_endpoint = EndPoint(ip_info=dst_ip)
            if not dst_ip_endpoint.node_id:
                dst_ip_node = Node(endpoints=[dst_ip_endpoint], node_type=NodeType.UNKNOWN)
                dst_ip_endpoint.node_id = dst_ip_node.node_id
                NODES[dst_ip_node.node_id] = dst_ip_node
            else:
                dst_ip_node = NODES[dst_ip_endpoint.node_id]
            IP_TO_ENDPOINTS[str(dst_ip.ipv4address)] = dst_ip_endpoint
            tcp_flow_info['dst_endpoint'] = dst_ip_endpoint

            tcp_flow_info['sport'] = get_float_value(flow, '@sport')
            tcp_flow_info['dport'] = get_float_value(flow, '@dport')
            flow_key = str(src_ip.ipv4address) + "-" + str(int(sport)) + "-" +\
                       str(dst_ip.ipv4address) + "-" + str(int(dport))


            # Generate the metrics for each direction
            total_losses_both_dir = 0.0
            total_losses_dir_0 = 0.0
            total_losses_dir_1 = 0.0
            for stream in flow['stream']:
                mtu = get_float_value(stream, '@mtu')
                nack = get_float_value(stream, '@nack')
                data = get_float_value(stream, '@ndata')
                nbytes = get_float_value(stream, '@seqlen')
                nfloss = get_float_value(stream, '@nfloss')
                nloss = get_float_value(stream, '@nloss')
                total_loss = nfloss + nloss
                total_losses_both_dir += total_loss
                if stream['@dir'] == 0:
                    total_losses_dir_0 = total_loss
                else:
                    total_losses_dir_1 = total_loss

            #Get the tcp flow and insert it into the IP_FLOWS dict
            tcp_flow = IP_FLOWS.get(flow_key, None)
            if not tcp_flow:
                tcp_metrics = TCPMetrics(total_loss=total_losses_both_dir)
                tcp_metrics_src_to_dst = TCPMetrics(total_loss=total_losses_dir_0)
                tcp_metrics_dst_to_src = TCPMetrics(total_loss=total_losses_dir_1)
                tcp_flow_info['flow_metrics'] = tcp_metrics
                tcp_flow_info['flow_metrics_src_to_dst'] = tcp_metrics_src_to_dst
                tcp_flow_info['flow_metrics_dst_to_src'] = tcp_metrics_dst_to_src
                tcp_flow = TCPFlow(**tcp_flow_info)
                IP_FLOWS[flow_key] = tcp_flow
            else:
                tcp_flow.flow_metrics.update_stats(dict(total_loss=total_losses_both_dir))
                tcp_flow.flow_metrics_src_to_dst.update_stats(dict(total_loss=total_losses_dir_0))
                tcp_flow.flow_metrics_dst_to_src.update_stats(dict(total_loss=total_losses_dir_1))
            #End of parsing TCP. Maybe print some stats.


"""
def main():
    op = OptionParser()
    op.add_option("-v", "--verbose", action="store_true", help="verbose", default=False)
    op.add_option("-w", "--wireless_summary", dest="wireless_summary",
                  help="Wireless Summary File", default=None)
    op.add_option("-n", "--node_summary", dest="node_summary",
                  help="Node Summary File", default=None)
    op.add_option("-t", "--tcpmystery_summary", dest="tcpmystery_summary",
                  help="TCP Mystery File", default=None)
    op.add_option("-l", "--tcploss_summary", dest="tcploss_summary",
                  help="TCP Loss File", default=None)
    (opts, args) = op.parse_args()
    if (not opts.wireless_summary or not opts.node_summary or
       not opts.tcpmystery_summary or not opts.tcploss_summary):
        op.error('wireless summar')
        data = read_xml(opts)
        json_data = parse_xml(xml_data=data, opts=opts)
        if opts.xml_file.endswith('.xml'):
            json_file = opts.xml_file[:-4] + ".json"
            else:
    json_file = opts.xml_file + ".json"
        write_json(json_data=json_data, output_file=json_file)

if __name__ == '__main__':
    main()
"""
